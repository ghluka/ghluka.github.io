const README = `generated by luka.onl/namemc

This ZIP contains the Minecraft skins to apply the
pixel art generated on the NameMC Skin Art generator.

To apply your skins, go to minecraft.net or in your
Minecraft launcher, set your skin to each PNG in this
zip in order from 0 to 25. In between each upload,
visit your NameMC profile and ensure that the skin
has been cached. Lastly, once all the skins are applied,
use whatever skin you were using before.`;

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const colorInput = document.getElementById('color');
const sizeInput = document.getElementById('size');
const clearBtn = document.getElementById('clear');
const fillBtn = document.getElementById('fill');
const upload = document.getElementById('upload');
const downloadBtn = document.getElementById('download');

const W = canvas.width;
const H = canvas.height;
const CELL = 9;
const GAP = 1;

function isDrawable(x, y) {
    const cx = Math.floor(x / CELL);
    const cy = Math.floor(y / CELL);
    if (cx === 0 && cy === 0) return false;
    const lx = x % CELL;
    const ly = y % CELL;
    if (lx < GAP || ly < GAP) return false;
    return true;
}

function drawBrushAt(x, y, size, rgba) {
    const r = Math.floor(size / 2);
    const img = ctx.getImageData(x - r, y - r, size, size);
    const data = img.data;

    for (let yy = 0; yy < size; yy++) {
        for (let xx = 0; xx < size; xx++) {
            const px = x - r + xx;
            const py = y - r + yy;
            if (px < 0 || py < 0 || px >= W || py >= H) continue;
            if (!isDrawable(px, py)) continue;
            const idx = (yy * size + xx) * 4;
            data[idx] = rgba[0];
            data[idx + 1] = rgba[1];
            data[idx + 2] = rgba[2];
            data[idx + 3] = rgba[3];
        }
    }
    ctx.putImageData(img, x - r, y - r);
}

function hexToRgba(hex) {
    hex = hex.replace('#', '');
    if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
    const n = parseInt(hex, 16);
    return [(n >> 16) & 255, (n >> 8) & 255, n & 255, 255];
}

let drawing = false;

function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = W / rect.width;
    const scaleY = H / rect.height;
    const cx = (e.touches ? e.touches[0].clientX : e.clientX);
    const cy = (e.touches ? e.touches[0].clientY : e.clientY);
    return {
        x: Math.floor((cx - rect.left) * scaleX),
        y: Math.floor((cy - rect.top) * scaleY)
    };
}

canvas.addEventListener('mousedown', e => {
    drawing = true;
    const pos = getPos(e);
    drawBrushAt(pos.x, pos.y, parseInt(sizeInput.value, 10), hexToRgba(colorInput.value));
});
window.addEventListener('mousemove', e => {
    if (!drawing) return;
    const pos = getPos(e);
    drawBrushAt(pos.x, pos.y, parseInt(sizeInput.value, 10), hexToRgba(colorInput.value));
});
window.addEventListener('mouseup', () => drawing = false);

clearBtn.onclick = () => {
    ctx.fillStyle = "#000";
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (isDrawable(x, y)) ctx.fillRect(x, y, 1, 1);
        }
    }
};
fillBtn.onclick = () => {
    ctx.fillStyle = colorInput.value;
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (isDrawable(x, y)) ctx.fillRect(x, y, 1, 1);
        }
    }
};
ctx.fillStyle = "#000";
for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
        if (isDrawable(x, y)) ctx.fillRect(x, y, 1, 1);
    }
}

upload.onchange = ev => {
    const f = ev.target.files[0];
    if (!f) return;
    const img = new Image();
    img.onload = () => {
        ctx.fillStyle = "#fff";
        for (let y = 0; y < H; y++) {
            for (let x = 0; x < W; x++) {
                if (isDrawable(x, y)) ctx.fillRect(x, y, 1, 1);
            }
        }
        const ratio = Math.min(W / img.width, H / img.height);
        const iw = img.width * ratio;
        const ih = img.height * ratio;
        ctx.drawImage(img, 0, 0, iw, ih);
        for (let y = 0; y < H; y++) {
            for (let x = 0; x < W; x++) {
                if (!isDrawable(x, y)) ctx.clearRect(x, y, 1, 1);
            }
        }
    };
    img.src = URL.createObjectURL(f);
};

const baseSkin = new Image();
baseSkin.src = "assets/img/skin.png";
downloadBtn.onclick = async () => {
    if (!baseSkin) {
        return;
    }

    const zip = new JSZip();
    const tmp = document.createElement('canvas');
    const tctx = tmp.getContext('2d');

    const SKIN_SIZE = 64;
    tmp.width = SKIN_SIZE;
    tmp.height = SKIN_SIZE;

    let count = 0;
    for (let cy = 0; cy < H / 10; cy++) {
        for (let cx = 0; cx < W / 10; cx++) {
            if (cx === 0 && cy === 0) continue; // skip first

            tctx.clearRect(0, 0, SKIN_SIZE, SKIN_SIZE);
            tctx.drawImage(baseSkin, 0, 0, SKIN_SIZE, SKIN_SIZE);

            const cellData = ctx.getImageData(cx * CELL, cy * CELL, CELL, CELL);

            // draw face
            const faceCanvas = document.createElement('canvas');
            faceCanvas.width = CELL;
            faceCanvas.height = CELL;
            faceCanvas.getContext('2d').putImageData(cellData, 0, 0);
            tctx.drawImage(faceCanvas, 7, 7);

            const dataURL = tmp.toDataURL("image/png");
            zip.file(`skin_${25-count}.png`, dataURL.split(',')[1], {
                base64: true
            });
            count++;
        }
    }

    zip.file("README.txt", README);
    const blob = await zip.generateAsync({
        type: "blob"
    });
    saveAs(blob, "skins.zip");
};